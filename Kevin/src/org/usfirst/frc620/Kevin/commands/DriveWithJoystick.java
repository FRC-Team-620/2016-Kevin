// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc620.Kevin.commands;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc620.Kevin.Robot;

/**
 *
 */
public class DriveWithJoystick extends Command {
	
	/*
	 * Determines which control system the robot uses
	 * 0 for double-joystick tank drive
	 * 1 for single xbox control tank drive
	 */
	public static short CONTROL_MODE = 1;
	
	
	double[][] axisValues;
	boolean[][] buttonPrints;
	int clock = 0;
	
	Joystick stickLeft;
	Joystick stickRight;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveWithJoystick() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	
    	axisValues = new double[2][];
    	buttonPrints = new boolean[2][];
    	stickLeft = Robot.oi.getJoystickLeft();
    	stickRight = Robot.oi.getJoystickRight();
    	axisValues[0] = new double[stickLeft.getAxisCount()];
    	axisValues[1] = new double[stickRight.getAxisCount()];
    	buttonPrints[0] = new boolean[stickLeft.getButtonCount()];
    	buttonPrints[1] = new boolean[stickRight.getButtonCount()];
    	
    	if(stickLeft.getName().trim().toLowerCase().equals("XBOX 360 For Windows (Controller)".trim().toLowerCase())) {
    		CONTROL_MODE = 1;
    		System.out.println("Left controller is XBox.");
    	}
    	else if(stickLeft.getName().trim().toLowerCase().equals("Logitech Attack 3".trim().toLowerCase())) {
    		CONTROL_MODE = 0;
    		System.out.println("Left controller is Joystick.");
    	}
    	else
    		System.out.println("Left Control " + stickLeft.getName() + " is not useable.");
    	
    	if(stickRight.getName().trim().toLowerCase().equals("XBOX 360 For Windows (Controller)".trim().toLowerCase()))
    		System.out.println("Right controller is XBox.");
    	else if(stickRight.getName().trim().toLowerCase().equals("Logitech Attack 3".trim().toLowerCase()))
    		System.out.println("Right controller is Joystick.");
    	else
    		System.out.println("Right control " + stickRight.getName() + " is not useable.");
    	
    }

    protected void drive() {
    	if(CONTROL_MODE == 0) {
    		
    		double left = 0, right = 0;
	    	
	    	left = stickLeft.getY();
	    	right = stickRight.getY();
	    	
	    	if(Math.abs(left)<0.2)
	    		left=0;
	    	if(Math.abs(right)<0.2)
	    		right=0;
	    	
	    	double throttle = (stickLeft.getRawAxis(2)-2)/-3;
	    	
	    	Robot.driveTrain.tankDrive(left*throttle, right*throttle);
	    	
    	} else if(CONTROL_MODE == 1) {
    		
    		double left = 0, right = 0;    		
    		left = stickLeft.getRawAxis(1);
    		right = stickLeft.getRawAxis(5);
    		
    		if(Math.abs(left)<0.2)
	    		left=0;
	    	if(Math.abs(right)<0.2)
	    		right=0;
	    	
	    	Robot.driveTrain.tankDrive(left,right);
    	}
    	
    }
    
    public void mapStick(Joystick stick, int num) {
    	clock++;
    	if(clock >= 5) {
	    	for(int x = 0; x < stick.getAxisCount(); x++) {
	    		try {
		    		if(Math.abs(stick.getRawAxis(x)-axisValues[num][x]) > 0.2) {
		    			System.out.println("Axis "+x+" Moved to "+stick.getRawAxis(x)+"On stick "+num);
		    		}
		    		axisValues[num][x] = stick.getRawAxis(x);
	    		} catch(Exception e) {
	    			System.out.println(e.getMessage());
	    		}
	    	}
	    	for(int x = 1; x <= stick.getButtonCount(); x++) {
	    		try {
	    			if(stick.getRawButton(x) & !buttonPrints[num][x-1]) {
	    				System.out.println("Button "+x+" pressed on stick "+num);
	    			}
	    			buttonPrints[num][x-1] = stick.getRawButton(x);
	    		} catch(Exception e) {
	    			System.out.println(e.getMessage());

	    		}
	    	}
	    	clock = 0;
    	}
    }
    
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	drive();
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
