// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package src.org.usfirst.frc620.Kevin.commands;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.command.Command;
import src.org.usfirst.frc620.Kevin.Robot;

public class DriveWithJoystick extends Command {
	
	/*
	 * Determines which control system the robot uses
	 * 0 for double-joystick tank drive
	 * 1 for single xbox control tank drive
	 * 2 for single xbox arcade drive
	 */
	public static short CONTROL_MODE = 1;
	
	
	double[][] axisValues;
	boolean[][] buttonPrints;
	int clock = 0;
	
	Joystick stickLeft;
	Joystick stickRight;

	boolean leftTrigger = false;
	boolean rightTrigger = false;
	
	double direction = 0;
	boolean straight = false;
	
	int mode = 0;
	
	double spinLeft = 0.05;
	double spinRight = 0.05;
	
	/**
	 * This property determines what state of barrier mode the robot is in.<br> 
	 * The state of the barrier mode is defined by three bits:
	 *   
	 * <p>   The least significant bit (the rightmost one that determines whether the number is even or odd) determines
	 * whether the robot is currently in barrier mode.<br><br>
	 * 
	 *    The next least significant bit (the 2's place) determines whether the B key is still being held down, in
	 * order to prevent the robot's mode from toggling 50 times every second for the duration of the time the key
	 * is held down.<br><br>
	 * 
	 *    The most significant bit of the three (the 4's place) determines whether the code that runs only on state
	 * change (i.e. lowering or raising the bucket and/or pistons) has been run, and when it is a 1 only remains so
	 * for 1 execute.<br></p>
	 */
	short barrierMode = 0;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public DriveWithJoystick() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	
    	axisValues = new double[2][];
    	buttonPrints = new boolean[2][];
    	stickLeft = Robot.oi.getXboxController();
    	stickRight = Robot.oi.getXboxController();
    	axisValues[0] = new double[stickLeft.getAxisCount()];
    	axisValues[1] = new double[stickRight.getAxisCount()];
    	buttonPrints[0] = new boolean[stickLeft.getButtonCount()];
    	buttonPrints[1] = new boolean[stickRight.getButtonCount()];
    	
//    	if(stickLeft.getName().trim().toLowerCase().equals("XBOX 360 For Windows (Controller)".trim().toLowerCase())) {
//    		CONTROL_MODE = 1;
//    		System.out.println("Left controller is XBox.");
//    	}
//    	else if(stickLeft.getName().trim().toLowerCase().equals("Logitech Attack 3".trim().toLowerCase())) {
//    		CONTROL_MODE = 0;
//    		System.out.println("Left controller is Joystick.");
//    	}
//    	else
//    		System.out.println("Left Control " + stickLeft.getName() + " is not useable.");
//    	
//    	if(stickRight.getName().trim().toLowerCase().equals("XBOX 360 For Windows (Controller)".trim().toLowerCase()))
//    		System.out.println("Right controller is XBox.");
//    	else if(stickRight.getName().trim().toLowerCase().equals("Logitech Attack 3".trim().toLowerCase()))
//    		System.out.println("Right controller is Joystick.");
//    	else
//    		System.out.println("Right control " + stickRight.getName() + " is not useable.");
    	
    }

    protected void drive() {
    	
    	double left = 0, right = 0, throttle = 1;
    	
    	if(CONTROL_MODE == 0) {
	    	
	    	left = stickLeft.getY();
	    	right = stickRight.getY();
	    	
	    	boolean upb, dnb;
	    	
	    	if(stickLeft.getRawButton(1)) {
	    		upb = stickLeft.getRawButton(5);
	    		dnb = stickLeft.getRawButton(4);
	    	} else if(stickRight.getRawButton(1)) {
	    		upb = stickRight.getRawButton(5);
	    		dnb = stickRight.getRawButton(4);
	    	} else {
	    		upb = stickLeft.getRawButton(3);
	    		dnb = stickRight.getRawButton(3);
	    	}
	    	
	    	if(!leftTrigger && upb) {
    			mode++;
    			mode = Math.min(mode, 1);
    		}
    		if(!rightTrigger && dnb) {
    			mode--;
    			mode = Math.max(mode, -1);
    		}
    		leftTrigger = upb;
    		rightTrigger = dnb;
    		
    		if(mode == 1)
    			throttle = 1.0 * ((stickLeft.getRawAxis(2)-2)/-3);
    		if(mode == 0)
    			throttle = 0.8 * ((stickLeft.getRawAxis(2)-2)/-3);
    		if(mode == -1) 
    			throttle = 0.5 * ((stickLeft.getRawAxis(2)-2)/-3);
	    	
	    	
	    	
    	} else if(CONTROL_MODE == 1) {
    		
    		left = stickLeft.getRawAxis(1);
    		right = stickLeft.getRawAxis(5);
    		
    		if(!leftTrigger && stickLeft.getRawAxis(3) > 0.7) {
    			mode++;
    			mode = Math.min(mode, 1);
    		}
    		if(!rightTrigger && stickLeft.getRawAxis(2) > 0.7) {
    			mode--;
    			mode = Math.max(mode, -1);
    		}
    		leftTrigger = stickLeft.getRawAxis(3) > 0.7;
    		rightTrigger = stickLeft.getRawAxis(2) > 0.7;
    		
    		if(mode == 1)
    			throttle = 1.0;
    		if(mode == 0)
    			throttle = 0.8;
    		if(mode == -1) 
    			throttle = 0.6;
    	}
    	
    	if(Math.abs(left)<0.2) {
    		left=0;
    		spinLeft = 0.05;
    	} else {
    		spinLeft *= 1.1;
    		spinLeft = Math.min(spinLeft, 1);
    	}
    	if(Math.abs(right)<0.2) {
    		right=0;
    		spinRight = 0.05;
    	} else {
    		spinRight *= 1.1;
    		spinRight = Math.min(spinRight, 1);
    	}
    	if(left > 0.9)
    		left = 1;
    	if(right > 0.9)
    		right = 1;
    	if(Math.abs(left-right)<0.2) {
    		if(!straight) {
    			
    			straight = true;
    		}
    		
    		left = right = Math.max(left, right);
    		
    	} else
    		straight = false;
    	
    	if (left > 0)
    		left = Math.pow(left, 2);
    	else
    		left = -Math.pow(left, 2);
    	if (right > 0)
    		right = Math.pow(right, 2);
    	else
    		right = -Math.pow(right, 2);
    	
    	if((barrierMode & 4) > 0)
			barrierMode ^= 4;
		if(stickLeft.getRawButton(2)) {
			if((barrierMode & 2) == 0)
				barrierMode ^= 7;
		} else
			if(barrierMode != (barrierMode &= 5))
		 		barrierMode |= 4;
    	
		if((barrierMode & 1) > 0) {
			throttle = 0.5;
		}
		
		if((barrierMode & 6) == 6) {
			if((barrierMode & 1) == 1) {
				//TODO Setup barrier mode
			} else {
				//TODO Take down barrier mode
			}
		}
		
    	if(CONTROL_MODE == 0 && stickLeft.getRawButton(1)) {
    		Robot.driveTrain.arcadeDrive(stickLeft.getY() * throttle, stickLeft.getX()*-throttle);
    	} else if (CONTROL_MODE == 0 && stickRight.getRawButton(1)) {
    		Robot.driveTrain.arcadeDrive(stickRight.getY() * throttle, stickRight.getX()*-throttle);
    	} else {
    		Robot.driveTrain.tankDrive(left*throttle, right*throttle);
    	}
    	
    }
    
    public void driveArcade() {
    	if(stickLeft.getRawButton(1))
    		Robot.driveTrain.arcadeDrive(0.5 * stickLeft.getRawAxis(1), 0.5 * stickRight.getRawAxis(0));
    	else
    		Robot.driveTrain.arcadeDrive(stickLeft.getRawAxis(1), stickRight.getRawAxis(0));
    }
    
    public void mapStick(Joystick stick, int num) {
    	clock++;
    	if(clock >= 5) {
	    	for(int x = 0; x < stick.getAxisCount(); x++) {
	    		try {
		    		if(Math.abs(stick.getRawAxis(x)-axisValues[num][x]) > 0.2) {
		    			System.out.println("Axis "+x+" Moved to "+stick.getRawAxis(x)+"On stick "+num);
		    		}
		    		axisValues[num][x] = stick.getRawAxis(x);
	    		} catch(Exception e) {
	    			System.out.println(e.getMessage());
	    		}
	    	}
	    	for(int x = 1; x <= stick.getButtonCount(); x++) {
	    		try {
	    			if(stick.getRawButton(x) & !buttonPrints[num][x-1]) {
	    				System.out.println("Button "+x+" pressed on stick "+num);
	    			}
	    			buttonPrints[num][x-1] = stick.getRawButton(x);
	    		} catch(Exception e) {
	    			System.out.println(e.getMessage());

	    		}
	    	}
	    	clock = 0;
    	}
    }
    
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	drive();
    	//driveArcade();
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    }
}
